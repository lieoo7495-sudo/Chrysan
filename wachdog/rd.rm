```python
#!/usr/bin/env python

#
# 文件系统监控工具 - 当磁盘空间或inode接近耗尽时发出警报
#
# 在Ubuntu系统上使用
#
# 示例:
# sudo fs-watchdog.py
#

import argparse
import socket
import subprocess
import sys
import os
import platform
import logging

# ===================== 配置区域 =====================
# 分区监控阈值配置
WORK_BYTES_THRESHOLD = 0.85      # WORK分区空间使用率警报阈值
WORK_INODES_THRESHOLD = 0.85     # WORK分区inode使用率警报阈值

STORE_BYTES_THRESHOLD = 0.85     # STORE分区空间使用率警报阈值
STORE_INODES_THRESHOLD = 0.85    # STORE分区inode使用率警报阈值

SCRATCH_QUOTA_THRESHOLD = 0.75   # SCRATCH分区配额使用率警报阈值
SCRATCH_GLOBAL_THRESHOLD = 100 * 2**40  # SCRATCH全局空间剩余警报阈值(100TB)

WORKSF_BYTES_THRESHOLD = 0.85    # WORKSF分区空间使用率警报阈值
WORKSF_INODES_THRESHOLD = 0.85   # WORKSF分区inode使用率警报阈值

# 分区容量配额
SCRATCH_QUOTA_LIMIT = 400 * 2**40    # SCRATCH配额限制 (400TB)
WORKSF_BYTES_LIMIT = 2 * 2**40       # WORKSF空间限制 (2TB)
WORKSF_INODES_LIMIT = 3 * 10**6      # WORKSF inode限制 (3百万)

# 广播配置
BROADCAST_ENABLED = True            # 是否启用终端广播
MESSAGE_LANGUAGE = "zh"             # 消息语言: 'zh' 中文, 'en' 英文

# 分区路径配置（根据实际情况修改）
WORK_PATH = "/work"
STORE_PATH = "/store"
SCRATCH_PATH = "/scratch"
WORKSF_PATH = "/worksf"

# 日志配置
LOG_FILE = "/var/log/fs-watchdog.log"
# ===================================================

def get_message(key):
    """根据语言设置获取消息内容"""
    messages = {
        "zh": {
            "alert_title": "【紧急】文件系统即将满载",
            "scratch_full": "SCRATCH空间使用率: {:.2f}% ({:.2f}TB/{:.2f}TB)",
            "worksf_full": "WORKSF空间使用率: {:.2f}% ({:.2f}GB/{:.2f}GB)",
            "inode_full": "{} inode使用率: {:.2f}% ({:.1f}M/{:.1f}M)",
            "available_full": "{}分区可用空间不足: {:.2f}TB (低于阈值 {:.2f}TB)",
            "prompt": "请检查存储使用情况或联系管理员",
            "normal": "所有分区状态正常"
        },
        "en": {
            "alert_title": "【URGENT】File System Approaching Full",
            "scratch_full": "SCRATCH usage: {:.2f}% ({:.2f}TB/{:.2f}TB)",
            "worksf_full": "WORKSF usage: {:.2f}% ({:.2f}GB/{:.2f}GB)",
            "inode_full": "{} inode usage: {:.2f}% ({:.1f}M/{:.1f}M)",
            "available_full": "{} available space low: {:.2f}TB (below threshold {:.2f}TB)",
            "prompt": "Please check storage usage or contact admin",
            "normal": "All partitions are in good standing"
        }
    }
    return messages[MESSAGE_LANGUAGE][key]

def setup_logging():
    """配置日志系统"""
    logging.basicConfig(
        filename=LOG_FILE,
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    formatter = logging.Formatter('%(levelname)s: %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

def broadcast_alert(msg):
    """向所有登录用户的终端发送警报消息"""
    if not BROADCAST_ENABLED:
        return
        
    try:
        # 使用wall命令广播消息
        broadcast_cmd = [
            "wall",
            f"\n\n***** {get_message('alert_title')} *****\n{msg}\n\n{get_message('prompt')}\n"
        ]
        
        # 需要root权限才能广播
        if os.geteuid() == 0:
            result = subprocess.run(
                broadcast_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            if result.returncode == 0:
                logging.info("警报已广播至所有终端")
            else:
                logging.error(f"广播失败: {result.stderr.strip()}")
        else:
            logging.warning("警报未广播：需要root权限以使用wall命令")
    except Exception as e:
        logging.error(f"广播过程中出错: {str(e)}")

def check_system_compatibility():
    """检查系统兼容性"""
    # 确认是Linux系统
    if platform.system() != "Linux":
        raise OSError("本脚本仅支持Linux系统")

def run_cmd(cmd, check=True):
    """执行系统命令并返回输出"""
    try:
        result = subprocess.run(
            cmd,
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE,
            check=check,
            encoding="utf-8",
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as exc:
        error_msg = f"命令执行失败: {' '.join(cmd)}\n错误信息: {exc.stderr.strip()}"
        logging.error(error_msg)
        if check:
            raise
        return ""

def parse_df_output(output):
    """解析df命令输出，返回分区信息的字典列表"""
    lines = output.splitlines()
    if len(lines) < 2:
        logging.warning("df命令输出不足")
        return []
    
    headers = lines[0].split()
    partitions = []
    
    try:
        for line in lines[1:]:
            parts = line.split()
            # 确保有足够的列
            if len(parts) < len(headers):
                continue
                
            partition_info = {}
            for i, header in enumerate(headers):
                partition_info[header] = parts[i]
            partitions.append(partition_info)
    except Exception as e:
        logging.error(f"解析df输出时出错: {str(e)}")
    
    return partitions

def get_args():
    """解析命令行参数"""
    parser = argparse.ArgumentParser()
    parser.add_argument("-d", "--debug", action='store_true', help="启用调试模式")
    parser.add_argument("--no-broadcast", action='store_true', help="禁用终端广播")
    parser.add_argument("--lang", choices=["zh", "en"], default=MESSAGE_LANGUAGE, 
                        help="设置消息语言 (zh: 中文, en: 英文)")
    parser.add_argument("--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR"], 
                        default="INFO", help="设置日志级别")
    return parser.parse_args()

def main():
    """主监控逻辑"""
    setup_logging()
    
    try:
        # 系统兼容性检查
        check_system_compatibility()
        
        # 解析命令行参数
        args = get_args()
        
        # 设置日志级别
        logging.getLogger().setLevel(args.log_level)
        
        # 设置全局语言
        global MESSAGE_LANGUAGE
        MESSAGE_LANGUAGE = args.lang
        
        # 设置是否广播
        global BROADCAST_ENABLED
        if args.no_broadcast:
            BROADCAST_ENABLED = False

        alerts = []
        
        def get_partition_usage(mount_point):
            """获取指定挂载点的使用情况"""
            cmd = ["df", "-B1", "-P", mount_point]
            response = run_cmd(cmd, check=False)
            
            partitions = parse_df_output(response)
            if not partitions:
                logging.warning(f"无法获取分区 {mount_point} 的使用情况")
                return None, None, None
                
            partition = partitions[0]
            try:
                size_bytes = int(partition["1K-blocks"]) * 1024
                used_bytes = int(partition["Used"]) * 1024
                avail_bytes = int(partition["Available"])
                return size_bytes, used_bytes, avail_bytes
            except (ValueError, KeyError) as e:
                logging.error(f"解析分区 {mount_point} 数据时出错: {str(e)}")
                return None, None, None
        
        def get_partition_inodes(mount_point):
            """获取指定挂载点的inode使用情况"""
            cmd = ["df", "-i", "-P", mount_point]
            response = run_cmd(cmd, check=False)
            
            partitions = parse_df_output(response)
            if not partitions:
                logging.warning(f"无法获取分区 {mount_point} 的inode使用情况")
                return None, None
                
            partition = partitions[0]
            try:
                total_inodes = int(partition["Inodes"])
                used_inodes = int(partition["IUsed"])
                return total_inodes, used_inodes
            except (ValueError, KeyError) as e:
                logging.error(f"解析分区 {mount_point} inode数据时出错: {str(e)}")
                return None, None
        
        def check_partition_bytes(partition_name, mount_point, hard_limit_bytes, threshold):
            """检查分区空间使用情况"""
            logging.debug(f"检查 {partition_name} 空间使用情况...")
            size_bytes, used_bytes, _ = get_partition_usage(mount_point)
            
            if size_bytes is None or used_bytes is None:
                return
                
            # 如果未提供硬限制，使用实际分区大小
            effective_limit = hard_limit_bytes if hard_limit_bytes is not None else size_bytes
            current_usage_percent = 100 * used_bytes / effective_limit
            
            if logging.getLogger().isEnabledFor(logging.DEBUG):
                logging.debug(f"{partition_name} 空间使用: {used_bytes/2**30:.2f}GB/{effective_limit/2**30:.2f}GB ({current_usage_percent:.2f}%)")
            
            if current_usage_percent/100 > threshold:
                if partition_name == "SCRATCH":
                    msg = get_message("scratch_full").format(
                        current_usage_percent,
                        used_bytes / 2**40,
                        effective_limit / 2**40
                    )
                else:
                    msg = get_message("worksf_full").format(
                        current_usage_percent,
                        used_bytes / 2**30,
                        effective_limit / 2**30
                    )
                alerts.append(msg)

        def check_partition_inodes(partition_name, mount_point, hard_limit_inodes, threshold):
            """检查分区inode使用情况"""
            logging.debug(f"检查 {partition_name} inode使用情况...")
            total_inodes, used_inodes = get_partition_inodes(mount_point)
            
            if total_inodes is None or used_inodes is None:
                return
                
            # 如果未提供硬限制，使用实际总inode数
            effective_limit = hard_limit_inodes if hard_limit_inodes is not None else total_inodes
            current_usage_percent = 100 * used_inodes / effective_limit
            
            if logging.getLogger().isEnabledFor(logging.DEBUG):
                logging.debug(f"{partition_name} inode使用: {used_inodes/1e6:.2f}M/{effective_limit/1e6:.2f}M ({current_usage_percent:.2f}%)")
            
            if current_usage_percent/100 > threshold:
                msg = get_message("inode_full").format(
                    partition_name,
                    current_usage_percent,
                    used_inodes / 1e6,
                    effective_limit / 1e6
                )
                alerts.append(msg)

        def check_available_space(partition_name, mount_point, threshold_bytes):
            """检查分区可用空间"""
            logging.debug(f"检查 {partition_name} 可用空间...")
            _, _, avail_bytes = get_partition_usage(mount_point)
            
            if avail_bytes is None:
                return
                
            if logging.getLogger().isEnabledFor(logging.DEBUG):
                logging.debug(f"{partition_name} 可用空间: {avail_bytes/2**40:.2f}TB")
            
            if avail_bytes < threshold_bytes:
                msg = get_message("available_full").format(
                    partition_name,
                    avail_bytes / 2**40,
                    threshold_bytes / 2**40
                )
                alerts.append(msg)

        # ========================= 监控逻辑 =========================
        
        # 监控WORK分区
        check_partition_bytes("WORK", WORK_PATH, None, WORK_BYTES_THRESHOLD)
        check_partition_inodes("WORK", WORK_PATH, None, WORK_INODES_THRESHOLD)
        
        # 监控STORE分区
        check_partition_bytes("STORE", STORE_PATH, None, STORE_BYTES_THRESHOLD)
        check_partition_inodes("STORE", STORE_PATH, None, STORE_INODES_THRESHOLD)
        
        # 监控SCRATCH分区
        check_partition_bytes("SCRATCH", SCRATCH_PATH, SCRATCH_QUOTA_LIMIT, SCRATCH_QUOTA_THRESHOLD)
        check_available_space("SCRATCH", SCRATCH_PATH, SCRATCH_GLOBAL_THRESHOLD)
        
        # 监控WORKSF分区
        check_partition_bytes("WORKSF", WORKSF_PATH, WORKSF_BYTES_LIMIT, WORKSF_BYTES_THRESHOLD)
        check_partition_inodes("WORKSF", WORKSF_PATH, WORKSF_INODES_LIMIT, WORKSF_INODES_THRESHOLD)
        
        # ==========================================================
        
        if alerts:
            alert_title = get_message("alert_title")
            alert_msg = "\n".join(alerts)
            
            logging.warning(alert_title)
            logging.warning(alert_msg)
            
            # 发送广播警报
            broadcast_alert(alert_msg)
            sys.exit(1)  # 退出状态码1表示有警报
        else:
            msg = get_message("normal")
            logging.info(msg)
            print(msg)
            sys.exit(0)  # 退出状态码0表示一切正常

    except PermissionError:
        error_msg = "错误：需要root权限运行此脚本\n请使用: sudo ./fs-watchdog.py"
        logging.error(error_msg)
        print(error_msg)
        sys.exit(1)
    except Exception as e:
        error_msg = f"脚本执行出错: {str(e)}"
        logging.exception(error_msg)
        print(error_msg)
        sys.exit(1)

if __name__ == "__main__":
    main()

sudo chmod +x fs-watchdog.py
sudo ./fs-watchdog.py

sudo ./fs-watchdog.py --debug --log-level DEBUG

sudo crontab -e
*/15 * * * * /path/to/fs-watchdog.py

```